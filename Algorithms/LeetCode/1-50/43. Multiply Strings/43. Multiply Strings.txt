====================================================
Problem 43. Multiply Strings
====================================================
Given two non-negative integers num1 and num2 
represented as strings, return the product of num1 
and num2, also represented as a string.

Example 1:

Input: num1 = "2", num2 = "3"
Output: "6"

Example 2:

Input: num1 = "123", num2 = "456"
Output: "56088"

Note:

    The length of both num1 and num2 is < 110.
    Both num1 and num2 contain only digits 0-9.
    Both num1 and num2 do not contain any leading 
zero, except the number 0 itself.
    You must not use any built-in BigInteger library 
or convert the inputs to integer directly.




====================================================
Analysis
====================================================
https://www.bilibili.com/video/av56189755?from=search&seid=7866410682806574113

------------------------------------------------------
[Addition and Multiplication]
Addition: 
	- carry always 0 or 1
	- sequential carrying not exists (adding carry does not result in new carrying): 
		 999
		+999
		-----
		  18
		 18
		18 
		-----
		1998

------------------------------------------------------
[Multiplication Approach 1]

	123
   * 45
   -----
    615
   492
   -----
   5535
  
------------------------------------------------------
[Multiplication Approach 2]

	123
   * 45
   -----
     15		(5*3)
	10		(5*20)
    5		(5*100)
    12		(40*3)
    8		(40*20)
   4		(40*100)
   -----
   5535   
   
   
------------------------------------------------------
[Length of multiplication]

length_max = len1 * len2

assume num1 = 999, num2 = 999 (largest possible combination)
then num1 * num2 (largest possible multiplication result) < 999 * 1000 = 999000


====================================================
Analysis 2: Multiplication in Details
====================================================

				9	9	9		num1
	*				9	1		num2
	----------------------		//Note1: result of num1 * [each digit] of num2 shall never generate "letter digit"(digit larger than 9)
				9	9	9		//Reason 1: tenth digit of multiplication is <= 8 (9 * 9 = 81)
	+			8	1			//Reason 2: carry is <= 1, hence result digit is always <= 9
	----------------------		
				18	0	9		//Note2: 9(2nd digit of 999) + 81 (9*9) = 90
	+		8	1				//		 9(1st digit of 999) + 90 = 180
	----------------------		//		 Or: 99 + 81 = 180, 18 is seen as the tenth digit
		!	9	9	0	9
	+	8	1					//Note3: why "letter digit" like 18 will always disappear after the whole process?
	----------------------		//Reason 0: the "letter digit" will only appear in 1's position, not 10th,
		9	0	9	0	9		//			because it was generated by the carry of last calculation
								//Reason 1: the largest possible "letter digit" is 18 (99 + 81 = 18 0), 
								//          and the largest possible digit multiplication result is 81(9*9)
								//			since 18 + 81 = 99 < 100, hence every time we only need to care
								//			about current and next position
								//Reason 2: for the process of num1 * the 2nd digit of num2, the result of the 
								//          left most digit (the !) will always be on the left of the result
								//			of the last digit result (999)
								//			then the left most digit (0) will always absorb the tenth digit of 
								//          the "letter digit" (like 81 + 18 = 99)
								
								
P.S.:
About Note 1:
the result of num1 * 1 (the 2nd digit of num2) = 999
the result of num1 * 9 (the first digit of num2) = 90909

No "letter digit" will exist in this result, 
"letter digit" will only appear whithin the calculation of each digit of num2



								
public static String multiply2(String num1, String num2) {
		
	char[] chs1 = num1.toCharArray();
	char[] chs2 = num2.toCharArray();
	int n1 = chs1.length, n2 = chs2.length;
	char[] res = new char[n1 + n2];
	Arrays.fill(res, '0');
	
	for(int j = n2 - 1; j >= 0; j--) {
		for(int i = n1 - 1; i >= 0; i--) {
			int product = (chs1[i] - '0') * (chs2[j] - '0');
			int tmp = (res[i + j + 1] - '0' + product);						//add product to current digit

			res[i + j + 1] = (char) (tmp%10 + '0');							//get the digit
			res[i + j] = (char) ((res[i + j] - '0' + tmp / 10) + '0');		//get the tens digit
		}
	}
	
	StringBuilder sb = new StringBuilder();
	boolean seen = false;
	for(char c : res) {
		if(c == '0' && !seen) continue;
		sb.append(c);
		seen = true;
	}
	
	return sb.length() == 0 ? "0" : sb.toString();
}
